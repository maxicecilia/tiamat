import os
import requests
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich import print as rprint

# GitHub API configuration
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GITHUB_URL = "https://api.github.com"

DEFAULT_VERSION = "0.0.1"

HEADERS = {
    "Authorization": f"token {GITHUB_TOKEN}",
    "Accept": "application/vnd.github+json",
}

console = Console()


# GitHub API URLs
def _get_url(path: str) -> str:
    """Get the GitHub API URL"""
    return f"{GITHUB_URL}/{path}"


class GitHubService:
    """Service for interacting with GitHub API"""

    @staticmethod
    @staticmethod
    def get_pending_commits(
        repo: str, base_branch: str, compare_branch: str, display_table: bool = True
    ) -> bool:
        """
        Compare two branches and show pending commits

        Args:
            repo: Repository name (format: owner/repo)
            base_branch: Base branch name
            compare_branch: Branch to compare with base

        Returns:
            bool: True if there are pending commits, False otherwise
        """
        compare_url = _get_url(f"repos/{repo}/compare/{base_branch}...{compare_branch}")

        response = requests.get(compare_url, headers=HEADERS)
        if response.status_code == 200:
            data = response.json()
            commits = data.get("commits", [])

            table = Table(
                title=f"\n[bold]📦 {repo} — {len(commits)} pending commit(s): {base_branch}...{compare_branch}[/bold]",
                title_justify="left",
            )
            table.add_column("Commit", style="dim")
            table.add_column("Author", style="green")
            table.add_column("Message", style="cyan")

            for commit in commits:
                sha = commit.get("sha")[:7]
                msg = commit.get("commit", {}).get("message", "").split("\n")[0]
                author = (
                    commit.get("commit", {}).get("author", {}).get("name", "Unknown")
                )
                table.add_row(sha, author, msg)

            if commits and display_table:
                console.print(table)
            elif display_table:
                rprint(
                    f"\n[bold blue]📦 {repo}[/bold blue] — [green]No pending commits[/green]: {base_branch}...{compare_branch}"
                )

            return len(commits) > 0
        else:
            rprint(
                f"[bold red]❌ Failed to fetch commits for {repo}: {response.status_code}[/bold red]"
            )
            rprint(response.text)
            return False

    @staticmethod
    def create_pull_request(repo, base_branch, head_branch):
        """
        Create a pull request between branches

        Args:
            repo: Repository name (format: owner/repo)
            base_branch: Target branch for the PR
            head_branch: Source branch for the PR

        Returns:
            bool: True if PR was created successfully or already exists, False otherwise
        """
        pr_url = _get_url(f"repos/{repo}/pulls")
        existing_prs_url = _get_url(
            f"repos/{repo}/pulls?head={head_branch}&base={base_branch}&state=open"
        )
        pr_payload = {
            "title": f"Merge {head_branch} into {base_branch} - {datetime.now().strftime('%B %Y')}",
            "head": head_branch,
            "base": base_branch,
            "body": "Auto-generated by Tiamat",
        }
        response = requests.post(pr_url, headers=HEADERS, json=pr_payload)

        if response.status_code == 201:
            pr = response.json()
            return pr["html_url"]
        elif response.status_code == 422:
            # Get existing PRs between these branches
            pr_response = requests.get(existing_prs_url, headers=HEADERS)
            if pr_response.status_code == 200 and pr_response.json():
                pr = pr_response.json()[0]
                return pr["html_url"]
            else:
                rprint(
                    f"[bold red]❌ Failed to create PR: {pr_response.status_code}[/bold red]"
                )
                rprint(pr_response.text)
                return None
        else:
            rprint(
                f"[bold red]❌ Failed to create PR: {response.status_code}[/bold red]"
            )
            rprint(response.text)
            return None

    @staticmethod
    def merge_pr(repo: str, pr_number: int):
        """
        Merge a pull request

        Args:
            repo: Repository name (format: owner/repo)
            pr_number: The number of the pull request to merge
        """
        merge_url = _get_url(f"repos/{repo}/pulls/{pr_number}/merge")
        merge_payload = {
            "commit_title": f"Merge {pr_number}",
            "commit_message": f"Merge {pr_number}",
            "merge_method": "merge",
        }
        response = requests.put(merge_url, headers=HEADERS, json=merge_payload)
        if response.status_code == 200:
            return True
        else:
            rprint(response.text)
            return False

    @staticmethod
    def is_token_valid():
        """Check if the GitHub token is set and valid"""
        if not GITHUB_TOKEN:
            return False

        test_url = _get_url("user")
        response = requests.get(test_url, headers=HEADERS)
        return response.status_code == 200

    @staticmethod
    def create_release(
        repo: str,
        tag_name: str,
        target_branch: str = "main",
        name: str = None,
        body: str = None,
        draft: bool = False,
        prerelease: bool = False,
    ) -> bool:
        """
        Create a new release on GitHub

        Args:
            repo: Repository name (format: owner/repo)
            tag_name: The name of the tag to create (e.g., v1.0.0)
            target_branch: The branch to target for the release (default: main)
            name: The name of the release (defaults to tag_name if not provided)
            body: The description of the release
            draft: Whether the release is a draft (default: False)
            prerelease: Whether the release is a pre-release (default: False)

        Returns:
            bool: True if release was created successfully, False otherwise
        """
        release_url = _get_url(f"repos/{repo}/releases")

        if not name:
            name = f"Release {tag_name}"

        payload = {
            "tag_name": tag_name,
            "target_commitish": target_branch,
            "name": name,
            "body": body,
            "draft": draft,
            "prerelease": prerelease,
            "generate_release_notes": True,
        }

        response = requests.post(release_url, headers=HEADERS, json=payload)

        if response.status_code in (200, 201):
            release_data = response.json()
            release_html_url = release_data.get("html_url")
            release_status = "draft " if draft else ""
            release_status += "pre-release" if prerelease else "release"

            rprint(
                f"[bold green]✅ {release_status.capitalize()} created:[/bold green] {release_html_url}"
            )
            return True
        else:
            rprint(
                f"[bold red]❌ Failed to create release: {response.status_code}[/bold red]"
            )
            error_message = response.json().get("message", response.text)
            rprint(f"[red]Error: {error_message}[/red]")
            return False

    @staticmethod
    def list_releases(repo: str, limit: int = 5) -> bool:
        """
        List recent releases for a repository

        Args:
            repo: Repository name (format: owner/repo)
            limit: Maximum number of releases to show (default: 5)

        Returns:
            bool: True if releases were found and displayed, False otherwise
        """
        releases_url = _get_url(f"repos/{repo}/releases")

        response = requests.get(releases_url, headers=HEADERS)

        if response.status_code == 200:
            releases = response.json()

            if not releases:
                rprint(f"[yellow]No releases found for {repo}[/yellow]")
                return False

            table = Table(title=f"Recent Releases for {repo}")
            table.add_column("Tag", style="cyan")
            table.add_column("Name", style="green")
            table.add_column("Created", style="blue")
            table.add_column("Status", style="yellow")
            table.add_column("URL")

            for release in releases[:limit]:
                tag = release.get("tag_name")
                name = release.get("name")
                created_at = datetime.fromisoformat(
                    release.get("created_at").replace("Z", "+00:00")
                ).strftime("%Y-%m-%d")

                status = []
                if release.get("draft"):
                    status.append("Draft")
                if release.get("prerelease"):
                    status.append("Pre-release")
                if not status:
                    status.append("Release")

                url = release.get("html_url")

                table.add_row(tag, name, created_at, ", ".join(status), url)

            console.print(table)
            return True
        else:
            rprint(
                f"[bold red]❌ Failed to fetch releases: {response.status_code}[/bold red]"
            )
            rprint(response.text)
            return False

    @staticmethod
    def trigger_workflow(
        repo: str, workflow_id: str, branch: str = "main", inputs: dict = None
    ) -> bool:
        """
        Trigger a GitHub Actions workflow run

        Args:
            repo: Repository name (format: owner/repo)
            workflow_id: The ID or filename of the workflow
            branch: The branch to run the workflow on (default: main)
            inputs: Optional inputs for the workflow dispatch event

        Returns:
            bool: True if workflow was triggered successfully, False otherwise
        """
        # Check if workflow_id is a filename or ID
        if not workflow_id.isdigit():
            # It's a filename, attempt to get the actual ID
            workflows_url = _get_url(f"repos/{repo}/actions/workflows")
            response = requests.get(workflows_url, headers=HEADERS)

            if response.status_code == 200:
                data = response.json()
                workflows = data.get("workflows", [])

                # Try exact match first
                for workflow in workflows:
                    path = workflow.get("path", "")
                    if (
                        path.endswith(workflow_id)
                        or workflow.get("name") == workflow_id
                    ):
                        workflow_id = str(workflow.get("id"))
                        break

                # If no exact match, try substring match
                if not workflow_id.isdigit():
                    for workflow in workflows:
                        path = workflow.get("path", "")
                        if workflow_id in path or workflow_id in workflow.get(
                            "name", ""
                        ):
                            workflow_id = str(workflow.get("id"))
                            break

            # If we still don't have a numeric ID, inform the user
            if not workflow_id.isdigit():
                rprint(
                    f"[bold red]❌ Could not find workflow matching '{workflow_id}'[/bold red]"
                )
                return False

        # Now we have a numeric ID, trigger the workflow
        dispatch_url = _get_url(
            f"repos/{repo}/actions/workflows/{workflow_id}/dispatches"
        )

        payload = {
            "ref": branch,
        }

        if inputs:
            payload["inputs"] = inputs

        response = requests.post(dispatch_url, headers=HEADERS, json=payload)

        if (
            response.status_code == 204
        ):  # GitHub returns 204 No Content for successful dispatches
            rprint(
                f"[bold green]✅ Workflow triggered successfully on {branch} branch[/bold green]"
            )
            rprint(f"[dim]Check the Actions tab for {repo} to see progress.[/dim]")
            return True
        else:
            rprint(
                f"[bold red]❌ Failed to trigger workflow: {response.status_code}[/bold red]"
            )
            error_message = response.text
            try:
                error_data = response.json()
                if "message" in error_data:
                    error_message = error_data["message"]
            except:
                pass
            rprint(f"[red]Error: {error_message}[/red]")
            return False

    @staticmethod
    def get_latest_version(repo: str) -> str:
        """
        Get the latest release version from a repository

        Args:
            repo: Repository name (format: owner/repo)

        Returns:
            str: The latest version string (e.g., 1.0.0) or 0.0.1 if no releases found
        """
        releases_url = _get_url(f"repos/{repo}/releases")

        response = requests.get(releases_url, headers=HEADERS)

        if response.status_code == 200:
            releases = response.json()

            if not releases:
                return DEFAULT_VERSION

            # Filter out pre-releases and drafts, and get the latest by creation date
            valid_releases = [
                r for r in releases if not r.get("prerelease") and not r.get("draft")
            ]

            if not valid_releases:
                return DEFAULT_VERSION

            latest_release = sorted(
                valid_releases,
                key=lambda x: datetime.fromisoformat(
                    x.get("created_at", "").replace("Z", "+00:00")
                ),
                reverse=True,
            )[0]

            return latest_release.get("tag_name", DEFAULT_VERSION)
        else:
            rprint(
                f"[bold yellow]⚠️ Could not fetch releases: {response.status_code}[/bold yellow]"
            )
            return DEFAULT_VERSION

    @staticmethod
    def bump_version(version: str, bump_type: str = "minor") -> str:
        """
        Bump a semantic version string

        Args:
            version: Version string (e.g., v1.0.0)
            bump_type: Type of bump - major, minor, or patch

        Returns:
            str: The bumped version string
        """
        # Strip 'v' prefix if present for processing
        has_v_prefix = version.startswith("v")
        if has_v_prefix:
            version = version[1:]

        # Handle invalid versions
        try:
            parts = [int(part) for part in version.split(".")]
        except ValueError:
            # If we can't parse the version, start with 0.0.0
            parts = [0, 0, 0]

        # Ensure we have at least 3 parts (major.minor.patch)
        while len(parts) < 3:
            parts.append(0)

        # Only use the first three parts for standard semver
        major, minor, patch = parts[0:3]

        # Bump the version according to bump_type
        if bump_type == "major":
            major += 1
            minor = 0
            patch = 0
        elif bump_type == "minor":
            minor += 1
            patch = 0
        else:  # patch
            patch += 1

        # Rebuild version string with 'v' prefix if it was present
        new_version = f"{major}.{minor}.{patch}"
        if has_v_prefix:
            new_version = "v" + new_version

        return new_version
